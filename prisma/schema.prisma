generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String              @id @default(cuid())
  email        String              @unique
  password     String
  firstName    String
  lastName     String
  phone        String?
  department   String?
  position     String?
  bio          String?
  avatar       String?
  role         UserRole            @default(USER)
  churchId     String?
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  availability Availability[]
  services     ServiceAssignment[]
  church       Church?             @relation(fields: [churchId], references: [id])
  swapRequestsFrom SwapRequest[]   @relation("SwapRequestFrom")
  swapRequestsTo   SwapRequest[]   @relation("SwapRequestTo")
  notifications Notification[]

  @@map("users")
}

model Church {
  id        String    @id @default(cuid())
  name      String    @unique
  address   String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  services  Service[]
  users     User[]

  @@map("churches")
}

model Service {
  id          String              @id @default(cuid())
  title       String
  description String?
  date        DateTime
  time        String
  location    String
  status      ServiceStatus       @default(DRAFT)
  churchId    String
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  assignments ServiceAssignment[]
  church      Church              @relation(fields: [churchId], references: [id])
  swapRequests SwapRequest[]

  @@map("services")
}

model ServiceAssignment {
  id        String           @id @default(cuid())
  serviceId String
  userId    String
  role      String
  status    AssignmentStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt
  service   Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade)
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([serviceId, userId])
  @@map("service_assignments")
}

model Availability {
  id        String             @id @default(cuid())
  userId    String
  date      DateTime
  status    AvailabilityStatus @default(AVAILABLE)
  createdAt DateTime           @default(now())
  updatedAt DateTime           @updatedAt
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, date])
  @@map("availability")
}

enum UserRole {
  ADMIN
  USER
}

enum ServiceStatus {
  DRAFT
  PUBLISHED
  CANCELLED
}

enum AssignmentStatus {
  PENDING
  CONFIRMED
  DECLINED
}

enum AvailabilityStatus {
  AVAILABLE
  UNAVAILABLE
  BUSY
}

model SwapRequest {
  id          String   @id @default(cuid())
  fromUserId  String
  toUserId    String
  serviceId   String
  date        DateTime
  message     String?
  status      String   @default("pending") // pending, accepted, rejected
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  fromUser User    @relation("SwapRequestFrom", fields: [fromUserId], references: [id])
  toUser   User    @relation("SwapRequestTo", fields: [toUserId], references: [id])
  service  Service @relation(fields: [serviceId], references: [id])

  @@map("swap_requests")
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  type      String   // swap_request, service_update, etc.
  title     String
  message   String
  data      Json?    // Additional data for the notification
  read      Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}
